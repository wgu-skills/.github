(()=>{var __webpack_modules__={166:(e,t,o)=>{const r=o(369);r.config();const checkEnvVariable=(e,t=null)=>{const o=process.env[e];if(typeof o==="undefined"){if(t!==null){console.warn(`Environment variable ${e} is not set. Using default value.`);return t}console.error(`Environment variable ${e} is missing.`);return null}return o};const s={collection:{slug:checkEnvVariable("COLLECTION_SLUG","default-slug"),uuid:checkEnvVariable("COLLECTION_UUID","168fae01-783d-422e-8b9f-93b9dc9102ea"),url:checkEnvVariable("COLLECTION_URL","https://aa-skill.wgu.edu/api/collections")},files:{output_dir:checkEnvVariable("OUTPUT_DIR","./dist")},git:{pat:checkEnvVariable("GIT_PAT",""),username:checkEnvVariable("GIT_USERNAME","davidjpetersen"),email:checkEnvVariable("GIT_EMAIL","david.petersen@wgu.edu"),org:checkEnvVariable("GIT_ORG","wgu-skills")}};Object.keys(s).forEach((e=>{Object.entries(s[e]).forEach((([t,o])=>{if(o===null){throw new Error(`Required environment variable ${t} is missing in ${e}`)}}))}));e.exports=s},875:(e,t,o)=>{const r=o(292);const s=o(17);const i=o(648);const{toCamelCase:n}=o(702);const c=o(166);const{output_dir:a}=c.files;const l="json";const u="yaml";const p=".skill.json";const _=".skill.yaml";const getFullPath=(e,t)=>s.join(a,e,t);const writeToFile=async(e,t)=>{console.log(`Writing file to ${e}`);try{await r.mkdir(s.dirname(e),{recursive:true});await r.writeFile(e,t);console.log(`File written successfully to ${e}`)}catch(e){console.error(`Error writing file: ${e}`);throw e}};const listFiles=async e=>{try{const t=await r.readdir(e);return t}catch(e){console.error("Error in listing files:",e);throw e}};const createIndexFile=async e=>{try{console.log("Creating index file");const t=await listFiles(getFullPath(e.slug,"skills"));const{imports:o,exports:r}=t.reduce(((e,t)=>{if(t.endsWith(p)){const o=n(s.basename(t,p));e.imports.push(`import ${o} from './skills/${t}';`);e.exports.push(o)}return e}),{imports:[],exports:[]});const i=`${o.join("\n")}\n\nexport { ${r.join(", ")} };`;await writeToFile(e.slug,"index.js",i);console.log("Index file created successfully.")}catch(e){console.error("Error in creating index file:",e);throw e}};const createPackageJsonFile=async e=>{console.log("Creating package JSON file");const t={name:e.slug,version:e.version,description:e.description,main:"index.js",scripts:{test:'echo "Error: no test specified" && exit 1'},author:"Western Governors University",license:"https://creativecommons.org/licenses/by-sa/4.0/"};try{await writeToFile(e.slug,`package.json`,JSON.stringify(t,null,4));console.log("Package JSON file created successfully.")}catch(e){console.error("Error in creating Package JSON file:",e);throw e}};const createReadmeFile=async e=>{console.log("Creating README file");const t=`# ${e.name}\n\n${e.description}\n\n## Skills\n\n`;console.log(t);try{const o=getFullPath(e.slug,"skills");console.log("Skills path:",o);const i=await listFiles(o);const n=i.filter((e=>e.endsWith(p))).map((async t=>{const o=getFullPath(e.slug,`skills/${t}`);const i=await r.readFile(o,"utf8");const n=JSON.parse(i);const c=s.basename(o,p);return`- ${n.skillName} [JSON](./skills/${c}${p}) [YAML](./skills/${c}${_})`})).join("\n");await writeToFile(`${e.slug} README.md`,`${t}${n}`);console.log("README file created successfully.")}catch(e){console.error("Error in creating README file:",e);throw e}};e.exports={writeToFile:writeToFile,FORMAT_JSON:l,FORMAT_YAML:u,createIndexFile:createIndexFile,createPackageJsonFile:createPackageJsonFile,createReadmeFile:createReadmeFile}},860:(e,t,o)=>{const r=o(309);const s=o(166);const i=o(446);const{url:n}=s.collection;const getCollection=async(e,t)=>{try{const o=await r(e,{headers:{Accept:"application/json"}});if(!o.ok){throw new Error(`Network response not ok: ${o.status}`)}const s=await o.json();return new i(s,t)}catch(e){console.error(`Error fetching collection for uuid: ${uuid}`,e);throw e}};e.exports=getCollection},736:(e,t,o)=>{const r=o(232);const s=o(147);const i=o(166);const{Octokit:n}=o(995);const c=new n({auth:i.git.pat});const isGitRepo=async e=>{const t=`${e}/.git`;try{s.accessSync(t,s.constants.R_OK);const o=r(e);return o.checkIsRepo()}catch(e){return false}};const initRepo=async e=>{const t=r(e);return t.init()};const checkIfRepoExists=async(e,t)=>{try{await c.repos.get({owner:e,repo:t});return true}catch(e){if(e.status===404){return false}console.error("Error checking repository existence:",e);throw e}};async function createGitHubRepo(e){try{const t=await c.repos.createForAuthenticatedUser({name:e,private:true});console.log("Repository created: ",t.data.html_url);return t.data.html_url}catch(e){console.error("Error creating repository: ",e);throw e}}const updateRepo=async()=>{const e=i.collection.slug;const t=i.files.output_dir;const o=`${t}/${e}`;const s=r(o);const n=await s.checkIsRepo();if(!n){console.log(`Initializing new Git repository in ${o}`);await s.init()}const c=await checkIfRepoExists(i.git.org,e);console.log(`The repo ${c?"exists":"doesn't exist"} on GitHub.`);if(!c){await createGitHubRepo(i.git.org,e).then((e=>console.log("Repo url: ",e))).catch((e=>console.error("Error creating repo: ",e)));console.log(`Repository ${i.git.org}/${e} created on GitHub.`)}const a=(new Date).toISOString();const l=await s.getRemotes(true);const u=l.some((e=>e.name==="origin"));if(!u){console.log("Adding remote origin");const t=`https://github.com/${i.git.org}/${e}.git`;await s.addRemote("origin",t)}await s.add(".",{"-f":null}).catch((e=>console.error("Error adding files: ",e)));await s.commit(`Automatically updated on ${a}`).catch((e=>console.error("Error committing: ",e)));await s.push("origin","main").catch((e=>console.error("Error pushing to repo: ",e)));console.log("Repository updated successfully.")};e.exports={isGitRepo:isGitRepo,initRepo:initRepo,updateRepo:updateRepo,createGitHubRepo:createGitHubRepo}},702:(e,t,o)=>{const r=o(135);const toCamelCase=e=>e.split("-").map(((e,t)=>e[0].toUpperCase()+e.slice(1).toLowerCase())).join("").replace(/[^a-zA-Z0-9]/g,"").replace(/^./,(e=>e.toLowerCase()));const createSlug=e=>r(e,{lower:true,strict:true});e.exports={createSlug:createSlug,toCamelCase:toCamelCase}},722:(e,t,o)=>{const r=o(648);const{FORMAT_JSON:s,FORMAT_YAML:i}=o(875);const{writeToFile:n}=o(875);const{createSlug:c}=o(702);const a=o(166);const l=o(17);class Skill{constructor(e,t){Object.assign(this,{...e,slug:c(e.skillName),collection:t})}get(){return{...this,slug:undefined}}async export(e,t){const o=l.join(a.files.output_dir,e.slug,`skills/${this.slug}.skill.${t}`);let c;if(t===s){c=JSON.stringify(this.get(),null,4)}else if(t===i){c=r.dump(this.get())}else{throw new Error(`Unsupported format: ${t}`)}console.log(`Exporting skill data to ${o}`);await n(o,c)}}e.exports=Skill},446:(e,t,o)=>{const{writeToFile:r,createIndexFile:s,createPackageJsonFile:i,createReadmeFile:n,FORMAT_JSON:c}=o(875);const{updateRepo:a}=o(736);const l=o(722);const u=o(166);const p=o(17);const _=o(648);class SkillCollection{constructor(e){const{uuid:t,id:o,name:r,description:s,type:i,status:n,"@context":c,owner:a,author:p,creator:_,creationDate:d,updateDate:g,publishDate:w,archiveDate:m,skills:f}=e;Object.assign(this,{uuid:t,id:o,name:r,description:s,type:i,status:n,context:c,owner:a,author:p,creator:_,creationDate:d,updateDate:g,publishDate:w,archiveDate:m,slug:u.collection.slug,skills:f.map((e=>new l(e)))})}async export(e){const t={...this,skills:this.skills.map((e=>e.get()))};const o=e===c?JSON.stringify(t,null,4):_.dump(t);const s=p.join(u.files.output_dir,this.slug,`collection.skill.${e}`);await r(s,o)}async exportSkills(e){await Promise.all(this.skills.map((t=>t.export(this,e))))}async createIndexFile(){await s(this)}async createPackageJsonFile(){await i(this)}async createReadmeFile(){await n(this)}async updateRepo(){await a()}}e.exports=SkillCollection},38:module=>{module.exports=eval("require")("@actions/core")},995:module=>{module.exports=eval("require")("@octokit/rest")},369:module=>{module.exports=eval("require")("dotenv")},648:module=>{module.exports=eval("require")("js-yaml")},309:module=>{module.exports=eval("require")("node-fetch")},232:module=>{module.exports=eval("require")("simple-git")},135:module=>{module.exports=eval("require")("slugify")},147:e=>{"use strict";e.exports=require("fs")},292:e=>{"use strict";e.exports=require("fs/promises")},17:e=>{"use strict";e.exports=require("path")}};var __webpack_module_cache__={};function __nccwpck_require__(e){var t=__webpack_module_cache__[e];if(t!==undefined){return t.exports}var o=__webpack_module_cache__[e]={exports:{}};var r=true;try{__webpack_modules__[e](o,o.exports,__nccwpck_require__);r=false}finally{if(r)delete __webpack_module_cache__[e]}return o.exports}(()=>{__nccwpck_require__.n=e=>{var t=e&&e.__esModule?()=>e["default"]:()=>e;__nccwpck_require__.d(t,{a:t});return t}})();(()=>{__nccwpck_require__.d=(e,t)=>{for(var o in t){if(__nccwpck_require__.o(t,o)&&!__nccwpck_require__.o(e,o)){Object.defineProperty(e,o,{enumerable:true,get:t[o]})}}}})();(()=>{__nccwpck_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)})();(()=>{__nccwpck_require__.r=e=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(e,"__esModule",{value:true})}})();if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var __webpack_exports__={};(()=>{"use strict";__nccwpck_require__.r(__webpack_exports__);var e=__nccwpck_require__(38);var t=__nccwpck_require__.n(e);var o=__nccwpck_require__(860);var r=__nccwpck_require__.n(o);async function run(){try{const t=(0,e.getInput)("skillCollectionUrl");const o=(0,e.getInput)("patToken");const s=github.context.repo.repo;console.log(`Skill Collection URL: ${t}`);const i=await r()(t,s);await Promise.all([i.export(FORMAT_JSON)]);i.updateRepo()}catch(t){(0,e.setFailed)(t.message)}}run()})();module.exports=__webpack_exports__})();